# Nova App Hub - Build on Merge Workflow
# Builds Docker image and creates Enclaver release image with embedded EIF

name: Build and Publish

on:
  # Only triggered via API from Nova Platform (no push trigger)
  workflow_dispatch:
    inputs:
      app_dir:
        description: 'App directory name to build (e.g., 123-hn-fetcher)'
        required: true
        type: string
      app_sqid:
        description: 'App SQID from Nova Platform (for callback)'
        required: false
        type: string
      build_id:
        description: 'Build ID from Nova Platform (for callback)'
        required: false
        type: string

env:
  # AWS Configuration
  AWS_REGION: us-east-1
  PUBLIC_ECR_REGISTRY: public.ecr.aws/d4t4u8d2
  ECR_REPOSITORY_PREFIX: sparsity-xyz/nova-apps
  S3_BUCKET: nova-app-hub-artifacts-004118891089

jobs:
  detect-changes:
    name: Detect Changed Apps
    runs-on: ubuntu-latest
    outputs:
      apps: ${{ steps.detect.outputs.apps }}
      has_changes: ${{ steps.detect.outputs.has_changes }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2
      
      - name: Detect changed apps
        id: detect
        run: |
          # Check if manually triggered with app_dir input
          if [ -n "${{ github.event.inputs.app_dir }}" ]; then
            APP_DIR="${{ github.event.inputs.app_dir }}"
            echo "Manual trigger for app: $APP_DIR"
            
            # Verify the app exists
            if [ -f "apps/$APP_DIR/nova-build.yaml" ]; then
              echo "apps=[\"$APP_DIR\"]" >> $GITHUB_OUTPUT
              echo "has_changes=true" >> $GITHUB_OUTPUT
            else
              echo "ERROR: App not found: apps/$APP_DIR/nova-build.yaml"
              exit 1
            fi
          else
            # Auto-detect from git diff (push trigger)
            CHANGED_FILES=$(git diff --name-only HEAD^ HEAD -- 'apps/')
            
            echo "Changed files:"
            echo "$CHANGED_FILES"
            
            # Extract unique app directories (exclude _example)
            APPS=()
            for file in $CHANGED_FILES; do
              if [[ "$file" =~ ^apps/([^/]+)/nova-build\.yaml$ ]]; then
                APP_NAME="${BASH_REMATCH[1]}"
                # Skip example directory
                if [ "$APP_NAME" != "_example" ]; then
                  if [[ ! " ${APPS[@]} " =~ " ${APP_NAME} " ]]; then
                    APPS+=("$APP_NAME")
                  fi
                fi
              fi
            done
            
            if [ ${#APPS[@]} -eq 0 ]; then
              echo "No app changes detected"
              echo "has_changes=false" >> $GITHUB_OUTPUT
              echo "apps=[]" >> $GITHUB_OUTPUT
            else
              echo "Apps to build: ${APPS[*]}"
              JSON_APPS=$(printf '%s\n' "${APPS[@]}" | jq -R . | jq -s -c .)
              echo "apps=$JSON_APPS" >> $GITHUB_OUTPUT
              echo "has_changes=true" >> $GITHUB_OUTPUT
            fi
          fi

  build:
    name: Build - ${{ matrix.app }}
    needs: detect-changes
    if: needs.detect-changes.outputs.has_changes == 'true'
    runs-on: ubuntu-latest
    
    # Permissions required for SLSA provenance and keyless signing
    permissions:
      contents: write      # For creating releases and committing BUILD_INFO.md
      packages: write      # For pushing to container registry
      id-token: write      # Required for OIDC/keyless signing via Sigstore
    
    strategy:
      fail-fast: false
      matrix:
        app: ${{ fromJson(needs.detect-changes.outputs.apps) }}
    
    outputs:
      image_uri: ${{ steps.enclaver.outputs.release_image }}
      image_digest: ${{ steps.enclaver.outputs.digest }}
      rekor_log_index: ${{ steps.sign.outputs.rekor_index }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
      
      - name: Parse build configuration
        id: config
        run: |
          CONFIG_FILE="apps/${{ matrix.app }}/nova-build.yaml"
          
          echo "Parsing configuration from: $CONFIG_FILE"
          
          # Extract configuration values from nova-build.yaml
          NAME=$(yq eval '.name' "$CONFIG_FILE")
          VERSION=$(yq eval '.version' "$CONFIG_FILE")
          REPO=$(yq eval '.repo' "$CONFIG_FILE")
          REF=$(yq eval '.ref' "$CONFIG_FILE")
          DIRECTORY=$(yq eval '.build.directory // "."' "$CONFIG_FILE")
          DOCKERFILE=$(yq eval '.build.dockerfile // "Dockerfile"' "$CONFIG_FILE")
          
          # Metadata
          DESCRIPTION=$(yq eval '.metadata.description // ""' "$CONFIG_FILE")
          MAINTAINER=$(yq eval '.metadata.maintainer // ""' "$CONFIG_FILE")
          LICENSE=$(yq eval '.metadata.license // ""' "$CONFIG_FILE")
          
          # Parse build args
          BUILD_ARGS=""
          ARGS_COUNT=$(yq eval '.build.args | length' "$CONFIG_FILE")
          if [ "$ARGS_COUNT" != "0" ] && [ "$ARGS_COUNT" != "null" ]; then
            for i in $(seq 0 $((ARGS_COUNT - 1))); do
              ARG_NAME=$(yq eval ".build.args[$i].name" "$CONFIG_FILE")
              ARG_VALUE=$(yq eval ".build.args[$i].value" "$CONFIG_FILE")
              BUILD_ARGS="${BUILD_ARGS}${ARG_NAME}=${ARG_VALUE},"
            done
          fi
          
          # Set outputs
          echo "name=$NAME" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "repo=$REPO" >> $GITHUB_OUTPUT
          echo "ref=$REF" >> $GITHUB_OUTPUT
          echo "directory=$DIRECTORY" >> $GITHUB_OUTPUT
          echo "dockerfile=$DOCKERFILE" >> $GITHUB_OUTPUT
          echo "build_args=$BUILD_ARGS" >> $GITHUB_OUTPUT
          echo "description=$DESCRIPTION" >> $GITHUB_OUTPUT
          echo "maintainer=$MAINTAINER" >> $GITHUB_OUTPUT
          echo "license=$LICENSE" >> $GITHUB_OUTPUT
      
      - name: Clone source repository
        id: clone
        run: |
          echo "Cloning repository: ${{ steps.config.outputs.repo }}"
          
          CLONE_DIR="source-repo"
          REF="${{ steps.config.outputs.ref }}"
          
          # Clone with the specified ref (works for branches and tags)
          # For commit SHAs, we clone default branch then checkout
          if [[ "$REF" =~ ^[a-f0-9]{40}$ ]]; then
            # Full commit SHA - clone then checkout
            git clone ${{ steps.config.outputs.repo }} "$CLONE_DIR"
            cd "$CLONE_DIR"
            git checkout "$REF"
          else
            # Branch or tag name
            git clone --branch "$REF" --depth 1 ${{ steps.config.outputs.repo }} "$CLONE_DIR"
            cd "$CLONE_DIR"
          fi
          
          # Get commit info
          COMMIT_SHA=$(git rev-parse HEAD)
          COMMIT_SHORT=$(git rev-parse --short HEAD)
          COMMIT_TIMESTAMP=$(git log -1 --pretty=%ct)
          COMMIT_MESSAGE=$(git log -1 --pretty=%B | head -1)
          COMMIT_AUTHOR=$(git log -1 --pretty=%an)
          COMMIT_DATE=$(git log -1 --pretty=%ci)
          
          echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
          echo "commit_short=$COMMIT_SHORT" >> $GITHUB_OUTPUT
          echo "commit_timestamp=$COMMIT_TIMESTAMP" >> $GITHUB_OUTPUT
          echo "commit_message=$COMMIT_MESSAGE" >> $GITHUB_OUTPUT
          echo "commit_author=$COMMIT_AUTHOR" >> $GITHUB_OUTPUT
          echo "commit_date=$COMMIT_DATE" >> $GITHUB_OUTPUT
          
          # Verify Dockerfile exists
          DOCKERFILE_PATH="${{ steps.config.outputs.directory }}/${{ steps.config.outputs.dockerfile }}"
          if [ ! -f "$DOCKERFILE_PATH" ]; then
            echo "ERROR: Dockerfile not found at $DOCKERFILE_PATH"
            exit 1
          fi
          
          echo "✅ Source repository cloned successfully"
          echo "   Commit: $COMMIT_SHA"
          echo "   Timestamp: $COMMIT_TIMESTAMP"
      
      - name: Determine SOURCE_DATE_EPOCH
        id: epoch
        run: |
          # Use commit timestamp for SOURCE_DATE_EPOCH
          EPOCH="${{ steps.clone.outputs.commit_timestamp }}"
          echo "Using commit timestamp as SOURCE_DATE_EPOCH: $EPOCH"
          echo "epoch=$EPOCH" >> $GITHUB_OUTPUT
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
        continue-on-error: true  # Continue even if Docker Hub login fails
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Login to Amazon ECR Public
        id: login-ecr
        run: |
          aws ecr-public get-login-password --region us-east-1 | \
            docker login --username AWS --password-stdin public.ecr.aws
      
      - name: Create ECR Public repository if not exists
        run: |
          REPO_NAME="${{ env.ECR_REPOSITORY_PREFIX }}/${{ steps.config.outputs.name }}"
          
          aws ecr-public describe-repositories --repository-names "$REPO_NAME" --region us-east-1 2>/dev/null || \
            aws ecr-public create-repository --repository-name "$REPO_NAME" --region us-east-1
      
      - name: Build application Docker image
        id: build
        run: |
          NAME="${{ steps.config.outputs.name }}"
          VERSION="${{ steps.config.outputs.version }}"
          COMMIT_SHORT="${{ steps.clone.outputs.commit_short }}"
          DIRECTORY="${{ steps.config.outputs.directory }}"
          DOCKERFILE="${{ steps.config.outputs.dockerfile }}"
          SOURCE_DATE_EPOCH="${{ steps.epoch.outputs.epoch }}"
          
          # Local image name (for enclaver to use)
          LOCAL_IMAGE="${NAME}:${VERSION}"
          
          # Build context path
          BUILD_CONTEXT="source-repo/${DIRECTORY}"
          DOCKERFILE_PATH="source-repo/${DIRECTORY}/${DOCKERFILE}"
          
          # Prepare build args for reproducibility
          BUILD_ARGS_FLAGS="--build-arg SOURCE_DATE_EPOCH=${SOURCE_DATE_EPOCH}"
          
          # Add user-defined build args
          USER_ARGS="${{ steps.config.outputs.build_args }}"
          if [ -n "$USER_ARGS" ]; then
            IFS=',' read -ra ARG_ARRAY <<< "$USER_ARGS"
            for arg in "${ARG_ARRAY[@]}"; do
              if [ -n "$arg" ]; then
                BUILD_ARGS_FLAGS="$BUILD_ARGS_FLAGS --build-arg $arg"
              fi
            done
          fi
          
          # Labels for traceability
          LABELS="--label org.opencontainers.image.source=${{ steps.config.outputs.repo }}"
          LABELS="$LABELS --label org.opencontainers.image.revision=${{ steps.clone.outputs.commit_sha }}"
          LABELS="$LABELS --label org.opencontainers.image.version=${VERSION}"
          LABELS="$LABELS --label org.opencontainers.image.created=$(date -u +'%Y-%m-%dT%H:%M:%SZ')"
          LABELS="$LABELS --label org.opencontainers.image.title=${NAME}"
          LABELS="$LABELS --label io.nova.source_date_epoch=${SOURCE_DATE_EPOCH}"
          
          echo "Building application Docker image..."
          echo "  SOURCE_DATE_EPOCH: $SOURCE_DATE_EPOCH"
          echo "  Context: $BUILD_CONTEXT"
          echo "  Dockerfile: $DOCKERFILE_PATH"
          
          # Build application image locally
          docker buildx build \
            --platform linux/amd64 \
            --file "$DOCKERFILE_PATH" \
            --tag "${LOCAL_IMAGE}" \
            $LABELS \
            $BUILD_ARGS_FLAGS \
            --provenance=false \
            --sbom=false \
            --load \
            "$BUILD_CONTEXT"
          
          echo "local_image=${LOCAL_IMAGE}" >> $GITHUB_OUTPUT
          
          echo "✅ Application Docker image built successfully"
          echo "   Image: ${LOCAL_IMAGE}"
      
      - name: Install Cosign
        uses: sigstore/cosign-installer@v3.7.0
      
      
      - name: Install Enclaver CLI
        run: |
          echo "Installing Enclaver CLI..."
          
          /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/sparsity-xyz/enclaver/refs/heads/sparsity/install.sh)"
          
          enclaver --version
          echo "✅ Enclaver CLI installed successfully"
      
      - name: Prepare enclaver.yaml
        id: enclaver_config
        run: |
          NAME="${{ steps.config.outputs.name }}"
          VERSION="${{ steps.config.outputs.version }}"
          COMMIT_SHORT="${{ steps.clone.outputs.commit_short }}"
          LOCAL_IMAGE="${{ steps.build.outputs.local_image }}"
          
          # ECR release image name
          ECR_IMAGE="${{ env.PUBLIC_ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}/${NAME}"
          RELEASE_IMAGE="${ECR_IMAGE}:${VERSION}-${COMMIT_SHORT}"
          
          mkdir -p output
          
          # Copy existing enclaver.yaml from app directory (generated by Nova Platform)
          ENCLAVER_FILE="apps/${{ matrix.app }}/enclaver.yaml"
          if [ ! -f "$ENCLAVER_FILE" ]; then
            echo "ERROR: enclaver.yaml not found at $ENCLAVER_FILE"
            exit 1
          fi
          
          cp "$ENCLAVER_FILE" output/enclaver.yaml
          
          # Update target and sources in enclaver.yaml with actual values
          yq eval -i ".target = \"${RELEASE_IMAGE}\"" output/enclaver.yaml
          yq eval -i ".sources.app = \"${LOCAL_IMAGE}\"" output/enclaver.yaml
          
          echo "Using enclaver.yaml:"
          cat output/enclaver.yaml
          
          echo "release_image=${RELEASE_IMAGE}" >> $GITHUB_OUTPUT
          echo "ecr_image=${ECR_IMAGE}" >> $GITHUB_OUTPUT
      
      - name: Pre-pull required images for Enclaver
        run: |
          echo "Pre-pulling required Docker images..."
          docker pull public.ecr.aws/d4t4u8d2/sparsity-ai/odyn:latest
          docker pull public.ecr.aws/d4t4u8d2/sparsity-ai/sleeve:latest
          docker pull public.ecr.aws/s2t1d4c6/enclaver-io/nitro-cli:latest
          echo "✅ Required images pre-pulled successfully"
      
      - name: Build Enclaver release image
        id: enclaver
        run: |
          NAME="${{ steps.config.outputs.name }}"
          VERSION="${{ steps.config.outputs.version }}"
          COMMIT_SHORT="${{ steps.clone.outputs.commit_short }}"
          RELEASE_IMAGE="${{ steps.enclaver_config.outputs.release_image }}"
          ECR_IMAGE="${{ steps.enclaver_config.outputs.ecr_image }}"
          
          echo "Building Enclaver release image..."
          echo "  App Name: $NAME"
          echo "  Version: $VERSION"
          echo "  Release Image: $RELEASE_IMAGE"
          
          # Build with enclaver (produces release image with embedded EIF)
          cd output
          
          # Run enclaver build and capture exit code
          set +e
          enclaver build --file enclaver.yaml 2>&1 | tee build-output.txt
          BUILD_EXIT_CODE=${PIPESTATUS[0]}
          set -e
          
          # Check for errors in output (enclaver may not always return non-zero on failure)
          if grep -q "Error:" build-output.txt; then
            echo "❌ Enclaver build FAILED - errors detected in output:"
            grep "Error:" build-output.txt
            exit 1
          fi
          
          if [ $BUILD_EXIT_CODE -ne 0 ]; then
            echo "❌ Enclaver build FAILED with exit code: $BUILD_EXIT_CODE"
            cat build-output.txt
            exit 1
          fi
          
          # Verify the release image was actually created
          if ! docker image inspect "${RELEASE_IMAGE}" > /dev/null 2>&1; then
            echo "❌ Enclaver build FAILED - release image not found locally: ${RELEASE_IMAGE}"
            echo "Build output:"
            cat build-output.txt
            exit 1
          fi
          
          echo "✅ Enclaver build completed successfully"
          
          # Extract PCR values from build output
          echo "Extracting PCR values..."
          PCR0=$(grep -oP 'PCR0:\s*\K[a-f0-9]+' build-output.txt || grep -oP '"PCR0":\s*"\K[^"]+' build-output.txt || echo "")
          PCR1=$(grep -oP 'PCR1:\s*\K[a-f0-9]+' build-output.txt || grep -oP '"PCR1":\s*"\K[^"]+' build-output.txt || echo "")
          PCR2=$(grep -oP 'PCR2:\s*\K[a-f0-9]+' build-output.txt || grep -oP '"PCR2":\s*"\K[^"]+' build-output.txt || echo "")
          
          echo "PCR0: $PCR0"
          echo "PCR1: $PCR1"
          echo "PCR2: $PCR2"
          
          # Create PCR JSON file
          cat > pcr.json << EOF
          {
            "PCR0": "$PCR0",
            "PCR1": "$PCR1",
            "PCR2": "$PCR2"
          }
          EOF
          
          echo "PCR values saved to pcr.json"
          
          # Push release image to ECR
          echo "Pushing release image to ECR..."
          docker push "${RELEASE_IMAGE}"
          docker tag "${RELEASE_IMAGE}" "${ECR_IMAGE}:${VERSION}"
          docker push "${ECR_IMAGE}:${VERSION}"
          docker tag "${RELEASE_IMAGE}" "${ECR_IMAGE}:latest"
          docker push "${ECR_IMAGE}:latest"
          
          # Get image digest
          DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "${RELEASE_IMAGE}" | cut -d'@' -f2 || echo "")
          
          # Set outputs (before signing so they're available)
          echo "release_image=${RELEASE_IMAGE}" >> $GITHUB_OUTPUT
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT
          echo "pcr0=$PCR0" >> $GITHUB_OUTPUT
          echo "pcr1=$PCR1" >> $GITHUB_OUTPUT
          echo "pcr2=$PCR2" >> $GITHUB_OUTPUT
          
          echo "✅ Release image pushed successfully"
          echo "   Image: ${RELEASE_IMAGE}"
          echo "   Digest: $DIGEST"
      
      - name: Sign container image (keyless via Sigstore)
        id: sign
        run: |
          RELEASE_IMAGE="${{ steps.enclaver.outputs.release_image }}"
          DIGEST="${{ steps.enclaver.outputs.digest }}"
          
          echo "Signing container image with cosign (keyless)..."
          echo "  Image: ${RELEASE_IMAGE}"
          echo "  Digest: ${DIGEST}"
          
          # Sign the image using keyless signing via Sigstore Fulcio
          # Capture output to extract Rekor log index
          SIGN_OUTPUT=$(cosign sign --yes "${RELEASE_IMAGE}@${DIGEST}" 2>&1) || true
          echo "$SIGN_OUTPUT"
          
          echo "✅ Image signed successfully"
          
          # Try to extract Rekor log index from sign output first
          REKOR_INDEX=$(echo "$SIGN_OUTPUT" | grep -oP 'tlog entry created with index:\s*\K\d+' || echo "")
          
          # If not found, try verify output
          if [ -z "$REKOR_INDEX" ]; then
            echo "Verifying signature to extract Rekor index..."
            VERIFY_OUTPUT=$(cosign verify \
              --certificate-identity-regexp='https://github.com/${{ github.repository }}/.*' \
              --certificate-oidc-issuer='https://token.actions.githubusercontent.com' \
              "${RELEASE_IMAGE}@${DIGEST}" 2>&1) || true
            
            echo "$VERIFY_OUTPUT"
            
            # Try multiple patterns to extract Rekor log index
            REKOR_INDEX=$(echo "$VERIFY_OUTPUT" | grep -oP '"logIndex":\s*\K\d+' | head -1 || \
                          echo "$VERIFY_OUTPUT" | grep -oP 'logIndex=\K\d+' | head -1 || \
                          echo "$VERIFY_OUTPUT" | jq -r '.[0].optional.Bundle.Payload.logIndex // empty' 2>/dev/null || \
                          echo "")
          fi
          
          echo "rekor_index=$REKOR_INDEX" >> $GITHUB_OUTPUT
          echo "✅ Signature verified - Rekor log index: $REKOR_INDEX"
      
      - name: Generate build-attestation.json
        id: attestation
        run: |
          NAME="${{ steps.config.outputs.name }}"
          VERSION="${{ steps.config.outputs.version }}"
          RELEASE_IMAGE="${{ steps.enclaver.outputs.release_image }}"
          DIGEST="${{ steps.enclaver.outputs.digest }}"
          PCR0="${{ steps.enclaver.outputs.pcr0 }}"
          PCR1="${{ steps.enclaver.outputs.pcr1 }}"
          PCR2="${{ steps.enclaver.outputs.pcr2 }}"
          IMAGE_REKOR_INDEX="${{ steps.sign.outputs.rekor_index }}"
          
          # Capture build timestamp
          BUILD_TIMESTAMP=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
          echo "build_timestamp=$BUILD_TIMESTAMP" >> $GITHUB_OUTPUT
          
          cd output
          
          # Create build-attestation.json following the schema from docs/build-attestation.md
          cat > build-attestation.json << EOF
          {
            "schema_version": "1.0",
            "type": "https://sparsity.cloud/nova/build-attestation/v1",
            "source": {
              "repo": "${{ steps.config.outputs.repo }}",
              "ref": "${{ steps.config.outputs.ref }}",
              "commit": "${{ steps.clone.outputs.commit_sha }}",
              "directory": "${{ steps.config.outputs.directory }}",
              "dockerfile": "${{ steps.config.outputs.dockerfile }}"
            },
            "enclave": {
              "pcr0": "$PCR0",
              "pcr1": "$PCR1",
              "pcr2": "$PCR2"
            },
            "build": {
              "timestamp": "$BUILD_TIMESTAMP",
              "source_date_epoch": "${{ steps.epoch.outputs.epoch }}",
              "github_run_id": "${{ github.run_id }}",
              "github_run_number": "${{ github.run_number }}",
              "builder_identity": "https://github.com/${{ github.repository }}/.github/workflows/build-on-merge.yml@${{ github.ref }}"
            },
            "image": {
              "uri": "${RELEASE_IMAGE}",
              "digest": "${DIGEST}",
              "rekor_log_index": "${IMAGE_REKOR_INDEX}"
            }
          }
          EOF
          
          echo "Build attestation saved to build-attestation.json"
          cat build-attestation.json
          
          # Compute sha256 hash for on-chain verification
          ATTESTATION_SHA256=$(sha256sum build-attestation.json | cut -d' ' -f1)
          echo "build_attestation_sha256=$ATTESTATION_SHA256" >> $GITHUB_OUTPUT
          echo "Build Attestation SHA256: $ATTESTATION_SHA256"
      
      - name: Sign build-attestation.json
        id: sign_attestation
        run: |
          cd output
          
          echo "Signing build-attestation.json with cosign (keyless)..."
          
          # Sign the attestation file using keyless signing via Sigstore Fulcio
          # Capture output to extract Rekor log index
          SIGN_OUTPUT=$(cosign sign-blob --yes \
            --output-signature build-attestation.json.sig \
            --output-certificate build-attestation.json.crt \
            build-attestation.json 2>&1) || true
          
          echo "$SIGN_OUTPUT"
          echo "✅ Build attestation signed successfully"
          
          # Extract Rekor log index from sign-blob output
          ATTESTATION_REKOR_INDEX=$(echo "$SIGN_OUTPUT" | grep -oP 'tlog entry created with index:\s*\K\d+' || echo "")
          
          # If not found in sign output, try verify output as fallback
          if [ -z "$ATTESTATION_REKOR_INDEX" ]; then
            echo "Verifying attestation signature to extract Rekor index..."
            VERIFY_OUTPUT=$(cosign verify-blob \
              --signature build-attestation.json.sig \
              --certificate build-attestation.json.crt \
              --certificate-identity-regexp='https://github.com/${{ github.repository }}/.*' \
              --certificate-oidc-issuer='https://token.actions.githubusercontent.com' \
              build-attestation.json 2>&1) || true
            
            echo "$VERIFY_OUTPUT"
            
            # Try multiple patterns to extract Rekor log index
            ATTESTATION_REKOR_INDEX=$(echo "$VERIFY_OUTPUT" | grep -oP 'tlog entry created with index:\s*\K\d+' || \
                                     echo "$VERIFY_OUTPUT" | grep -oP '"logIndex":\s*\K\d+' | head -1 || \
                                     echo "$VERIFY_OUTPUT" | grep -oP 'logIndex=\K\d+' | head -1 || \
                                     echo "")
          fi
          
          echo "attestation_rekor_index=$ATTESTATION_REKOR_INDEX" >> $GITHUB_OUTPUT
          echo "✅ Attestation signature verified - Rekor log index: $ATTESTATION_REKOR_INDEX"
      
      - name: Upload artifacts to S3
        run: |
          APP_NAME="${{ steps.config.outputs.name }}"
          VERSION="${{ steps.config.outputs.version }}"
          
          echo "Uploading artifacts to S3..."
          
          # Upload build attestation and signature
          aws s3 cp output/build-attestation.json "s3://${{ env.S3_BUCKET }}/builds/${APP_NAME}/${VERSION}/build-attestation.json"
          aws s3 cp output/build-attestation.json.sig "s3://${{ env.S3_BUCKET }}/builds/${APP_NAME}/${VERSION}/build-attestation.json.sig"
          aws s3 cp output/build-attestation.json.crt "s3://${{ env.S3_BUCKET }}/builds/${APP_NAME}/${VERSION}/build-attestation.json.crt"
          
          # Upload other build artifacts
          aws s3 cp output/pcr.json "s3://${{ env.S3_BUCKET }}/builds/${APP_NAME}/${VERSION}/pcr.json"
          aws s3 cp output/build-output.txt "s3://${{ env.S3_BUCKET }}/builds/${APP_NAME}/${VERSION}/build-output.txt"
          aws s3 cp output/enclaver.yaml "s3://${{ env.S3_BUCKET }}/builds/${APP_NAME}/${VERSION}/enclaver.yaml"
          
          echo "✅ Artifacts uploaded successfully"
          echo "  Attestation: s3://${{ env.S3_BUCKET }}/builds/${APP_NAME}/${VERSION}/build-attestation.json"
          echo "  Signature: s3://${{ env.S3_BUCKET }}/builds/${APP_NAME}/${VERSION}/build-attestation.json.sig"
          echo "  Certificate: s3://${{ env.S3_BUCKET }}/builds/${APP_NAME}/${VERSION}/build-attestation.json.crt"
      
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.config.outputs.name }}-v${{ steps.config.outputs.version }}
          name: "${{ steps.config.outputs.name }} v${{ steps.config.outputs.version }}"
          body: |
            ## AWS Nitro Enclave Build (via Enclaver)
            
            - **Application**: ${{ steps.config.outputs.name }}
            - **Version**: ${{ steps.config.outputs.version }}
            - **Build Time**: ${{ steps.attestation.outputs.build_timestamp }}
            - **Workflow Run Number**: ${{ github.run_number }}
            
            ## Source
            
            - **Repository**: ${{ steps.config.outputs.repo }}
            - **Ref**: ${{ steps.config.outputs.ref }}
            - **Commit**: `${{ steps.clone.outputs.commit_sha }}`
            - **Commit Message**: ${{ steps.clone.outputs.commit_message }}
            - **Directory**: `${{ steps.config.outputs.directory }}`
            - **Dockerfile**: `${{ steps.config.outputs.dockerfile }}`
            - **SOURCE_DATE_EPOCH**: `${{ steps.epoch.outputs.epoch }}`
            
            ## PCR Values (Platform Configuration Registers)
            
            These values can be used for remote attestation to verify the enclave identity.
            
            | PCR | Value |
            |-----|-------|
            | **PCR0** | `${{ steps.enclaver.outputs.pcr0 }}` |
            | **PCR1** | `${{ steps.enclaver.outputs.pcr1 }}` |
            | **PCR2** | `${{ steps.enclaver.outputs.pcr2 }}` |
            
            ## Release Docker Image
            
            The release image contains the EIF and Enclaver runtime:
            
            ```
            ${{ steps.enclaver.outputs.release_image }}
            ```
            
            **Digest**: `${{ steps.enclaver.outputs.digest }}`
            
            ## Build Attestation
            
            | Property | Value |
            |----------|-------|
            | **File** | [build-attestation.json](https://github.com/${{ github.repository }}/releases/download/${{ steps.config.outputs.name }}-v${{ steps.config.outputs.version }}/build-attestation.json) |
            | **SHA256** | `${{ steps.attestation.outputs.build_attestation_sha256 }}` |
            
            ## SLSA Provenance & Signature Verification
            
            This image and build attestation are signed using [Sigstore cosign](https://sigstore.dev) with keyless signing.
            
            - **Image Rekor Log Index**: [`${{ steps.sign.outputs.rekor_index }}`](https://search.sigstore.dev/?logIndex=${{ steps.sign.outputs.rekor_index }})
            - **Attestation Rekor Log Index**: [`${{ steps.sign_attestation.outputs.attestation_rekor_index }}`](https://search.sigstore.dev/?logIndex=${{ steps.sign_attestation.outputs.attestation_rekor_index }})
            
            ### Verify Container Image Signature
            
            ```bash
            cosign verify \
              --certificate-identity-regexp='https://github.com/${{ github.repository }}/.*' \
              --certificate-oidc-issuer='https://token.actions.githubusercontent.com' \
              ${{ steps.enclaver.outputs.release_image }}@${{ steps.enclaver.outputs.digest }}
            ```
            
            ### Verify Build Attestation Signature
            
            ```bash
            # Download attestation files
            curl -LO https://github.com/${{ github.repository }}/releases/download/${{ steps.config.outputs.name }}-v${{ steps.config.outputs.version }}/build-attestation.json
            curl -LO https://github.com/${{ github.repository }}/releases/download/${{ steps.config.outputs.name }}-v${{ steps.config.outputs.version }}/build-attestation.json.sig
            curl -LO https://github.com/${{ github.repository }}/releases/download/${{ steps.config.outputs.name }}-v${{ steps.config.outputs.version }}/build-attestation.json.crt
            
            # Verify signature
            cosign verify-blob \
              --signature build-attestation.json.sig \
              --certificate build-attestation.json.crt \
              --certificate-identity-regexp='https://github.com/${{ github.repository }}/.*' \
              --certificate-oidc-issuer='https://token.actions.githubusercontent.com' \
              build-attestation.json
            ```
            
            ## Usage
            
            Run on an EC2 instance with Nitro Enclave support:
            
            ```bash
            docker pull ${{ steps.enclaver.outputs.release_image }}
            docker run --rm --privileged ${{ steps.enclaver.outputs.release_image }}
            ```
            
            ## Verification
            
            To verify this build:
            
            1. Check the [GitHub Actions run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
            2. Verify PCR values match the expected values for your attestation policy
            3. Verify the container image signature using cosign
            4. Verify the build attestation signature using cosign
          draft: false
          prerelease: false
          files: |
            output/build-attestation.json
            output/build-attestation.json.sig
            output/build-attestation.json.crt
            output/pcr.json
            output/enclaver.yaml
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Summary
        run: |
          echo "## Build Summary for ${{ steps.config.outputs.name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "✅ **Build Successful!**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Application Info" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Name | ${{ steps.config.outputs.name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Version | ${{ steps.config.outputs.version }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Build Time | ${{ steps.attestation.outputs.build_timestamp }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Workflow Run Number | ${{ github.run_number }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Source" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Repository | ${{ steps.config.outputs.repo }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Ref | ${{ steps.config.outputs.ref }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Commit | \`${{ steps.clone.outputs.commit_sha }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Commit Message | ${{ steps.clone.outputs.commit_message }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Directory | \`${{ steps.config.outputs.directory }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Dockerfile | \`${{ steps.config.outputs.dockerfile }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| SOURCE_DATE_EPOCH | \`${{ steps.epoch.outputs.epoch }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### PCR Values (Platform Configuration Registers)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "These values can be used for remote attestation to verify the enclave identity." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| PCR | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-----|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **PCR0** | \`${{ steps.enclaver.outputs.pcr0 }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **PCR1** | \`${{ steps.enclaver.outputs.pcr1 }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **PCR2** | \`${{ steps.enclaver.outputs.pcr2 }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Release Docker Image" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "The release image contains the EIF and Enclaver runtime:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "${{ steps.enclaver.outputs.release_image }}" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Digest**: \`${{ steps.enclaver.outputs.digest }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Build Attestation" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **File** | [build-attestation.json](https://github.com/${{ github.repository }}/releases/download/${{ steps.config.outputs.name }}-v${{ steps.config.outputs.version }}/build-attestation.json) |" >> $GITHUB_STEP_SUMMARY
          echo "| **SHA256** | \`${{ steps.attestation.outputs.build_attestation_sha256 }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "> **Note**: If you want to verify the Docker image signature or build-attestation, please visit the Release Page for detailed verification instructions." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- [GitHub Release](${{ github.server_url }}/${{ github.repository }}/releases/tag/${{ steps.config.outputs.name }}-v${{ steps.config.outputs.version }})" >> $GITHUB_STEP_SUMMARY
      
      # Callback to Nova Platform (optional - does not fail the build)
      - name: Callback to Nova Platform (Success)
        if: success() && github.event.inputs.app_sqid != '' && github.event.inputs.build_id != ''
        continue-on-error: true
        run: |
          echo "Sending success callback to Nova Platform..."
          API_URL="${NOVA_PLATFORM_API_URL%/}"  # Strip trailing slash if present
          curl -X POST "${API_URL}/api/builds/callback" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${{ secrets.NOVA_PLATFORM_CALLBACK_API_KEY }}" \
            -d '{
              "app_sqid": "${{ github.event.inputs.app_sqid }}",
              "build_id": ${{ github.event.inputs.build_id }},
              "status": "success",
              "image_uri": "${{ steps.enclaver.outputs.release_image }}",
              "image_digest": "${{ steps.enclaver.outputs.digest }}",
              "git_commit": "${{ steps.clone.outputs.commit_sha }}",
              "git_commit_short": "${{ steps.clone.outputs.commit_short }}",
              "pcr0": "${{ steps.enclaver.outputs.pcr0 }}",
              "pcr1": "${{ steps.enclaver.outputs.pcr1 }}",
              "pcr2": "${{ steps.enclaver.outputs.pcr2 }}",
              "github_run_id": "${{ github.run_id }}",
              "build_attestation_url": "https://github.com/${{ github.repository }}/releases/download/${{ steps.config.outputs.name }}-v${{ steps.config.outputs.version }}/build-attestation.json",
              "build_attestation_sha256": "${{ steps.attestation.outputs.build_attestation_sha256 }}"
            }' || echo "Callback failed, but continuing..."
        env:
          NOVA_PLATFORM_API_URL: ${{ secrets.NOVA_PLATFORM_API_URL }}
      
      - name: Callback to Nova Platform (Failure)
        if: failure() && github.event.inputs.app_sqid != '' && github.event.inputs.build_id != ''
        continue-on-error: true
        run: |
          echo "Sending failure callback to Nova Platform..."
          API_URL="${NOVA_PLATFORM_API_URL%/}"  # Strip trailing slash if present
          curl -X POST "${API_URL}/api/builds/callback" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${{ secrets.NOVA_PLATFORM_CALLBACK_API_KEY }}" \
            -d '{
              "app_sqid": "${{ github.event.inputs.app_sqid }}",
              "build_id": ${{ github.event.inputs.build_id }},
              "status": "failed",
              "error_message": "Build failed. See GitHub Actions run ${{ github.run_id }} for details.",
              "github_run_id": "${{ github.run_id }}"
            }' || echo "Callback failed, but continuing..."
        env:
          NOVA_PLATFORM_API_URL: ${{ secrets.NOVA_PLATFORM_API_URL }}
