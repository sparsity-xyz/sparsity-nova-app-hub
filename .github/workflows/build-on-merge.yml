# Nova App Hub - Build on Merge Workflow
# Builds Docker image and creates Enclaver release image with embedded EIF

name: Build and Publish

on:
  push:
    branches: [main]
    paths:
      - 'apps/**'
  workflow_dispatch:
    inputs:
      app_name:
        description: 'App directory name to build (e.g., hn-fetcher)'
        required: true
        type: string

env:
  # AWS Configuration (from CloudFormation stack outputs)
  AWS_REGION: us-west-1
  ECR_REGISTRY: 004118891089.dkr.ecr.us-west-1.amazonaws.com
  ECR_REPOSITORY_PREFIX: nova-apps
  S3_BUCKET: nova-app-hub-artifacts-004118891089

jobs:
  detect-changes:
    name: Detect Changed Apps
    runs-on: ubuntu-latest
    outputs:
      apps: ${{ steps.detect.outputs.apps }}
      has_changes: ${{ steps.detect.outputs.has_changes }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2
      
      - name: Detect changed apps
        id: detect
        run: |
          # Check if manually triggered with app_name input
          if [ -n "${{ github.event.inputs.app_name }}" ]; then
            APP_NAME="${{ github.event.inputs.app_name }}"
            echo "Manual trigger for app: $APP_NAME"
            
            # Verify the app exists
            if [ -f "apps/$APP_NAME/nova-build.yaml" ]; then
              echo "apps=[\"$APP_NAME\"]" >> $GITHUB_OUTPUT
              echo "has_changes=true" >> $GITHUB_OUTPUT
            else
              echo "ERROR: App not found: apps/$APP_NAME/nova-build.yaml"
              exit 1
            fi
          else
            # Auto-detect from git diff (push trigger)
            CHANGED_FILES=$(git diff --name-only HEAD^ HEAD -- 'apps/')
            
            echo "Changed files:"
            echo "$CHANGED_FILES"
            
            # Extract unique app directories (exclude _example)
            APPS=()
            for file in $CHANGED_FILES; do
              if [[ "$file" =~ ^apps/([^/]+)/nova-build\.yaml$ ]]; then
                APP_NAME="${BASH_REMATCH[1]}"
                # Skip example directory
                if [ "$APP_NAME" != "_example" ]; then
                  if [[ ! " ${APPS[@]} " =~ " ${APP_NAME} " ]]; then
                    APPS+=("$APP_NAME")
                  fi
                fi
              fi
            done
            
            if [ ${#APPS[@]} -eq 0 ]; then
              echo "No app changes detected"
              echo "has_changes=false" >> $GITHUB_OUTPUT
              echo "apps=[]" >> $GITHUB_OUTPUT
            else
              echo "Apps to build: ${APPS[*]}"
              JSON_APPS=$(printf '%s\n' "${APPS[@]}" | jq -R . | jq -s -c .)
              echo "apps=$JSON_APPS" >> $GITHUB_OUTPUT
              echo "has_changes=true" >> $GITHUB_OUTPUT
            fi
          fi

  build:
    name: Build - ${{ matrix.app }}
    needs: detect-changes
    if: needs.detect-changes.outputs.has_changes == 'true'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        app: ${{ fromJson(needs.detect-changes.outputs.apps) }}
    
    outputs:
      image_uri: ${{ steps.enclaver.outputs.release_image }}
      image_digest: ${{ steps.enclaver.outputs.digest }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
      
      - name: Parse build configuration
        id: config
        run: |
          CONFIG_FILE="apps/${{ matrix.app }}/nova-build.yaml"
          
          echo "Parsing configuration from: $CONFIG_FILE"
          
          # Extract configuration values
          NAME=$(yq eval '.name' "$CONFIG_FILE")
          VERSION=$(yq eval '.version' "$CONFIG_FILE")
          REPO=$(yq eval '.repo' "$CONFIG_FILE")
          BRANCH=$(yq eval '.branch' "$CONFIG_FILE")
          COMMIT=$(yq eval '.commit // ""' "$CONFIG_FILE")
          DIRECTORY=$(yq eval '.build.directory // "."' "$CONFIG_FILE")
          DOCKERFILE=$(yq eval '.build.dockerfile // "Dockerfile"' "$CONFIG_FILE")
          
          # Enclave configuration (build-time only)
          DEBUG_MODE=$(yq eval '.enclave.debug_mode // false' "$CONFIG_FILE")
          
          # Enclaver configuration
          INGRESS_PORT=$(yq eval '.enclaver.ingress_port // 8000' "$CONFIG_FILE")
          API_PORT=$(yq eval '.enclaver.api_port // 9000' "$CONFIG_FILE")
          AUX_API_PORT=$(yq eval '.enclaver.aux_api_port // 9001' "$CONFIG_FILE")
          MEMORY_MB=$(yq eval '.enclaver.memory_mb // 1500' "$CONFIG_FILE")
          EGRESS_ALLOW=$(yq eval '.enclaver.egress_allow // []' "$CONFIG_FILE")
          
          # Reproducible build settings
          REPRODUCIBLE_ENABLED=$(yq eval '.reproducible.enabled // true' "$CONFIG_FILE")
          SOURCE_DATE_EPOCH=$(yq eval '.reproducible.source_date_epoch // ""' "$CONFIG_FILE")
          
          # Metadata
          DESCRIPTION=$(yq eval '.metadata.description // ""' "$CONFIG_FILE")
          MAINTAINER=$(yq eval '.metadata.maintainer // ""' "$CONFIG_FILE")
          LICENSE=$(yq eval '.metadata.license // ""' "$CONFIG_FILE")
          
          # Parse build args
          BUILD_ARGS=""
          ARGS_COUNT=$(yq eval '.build.args | length' "$CONFIG_FILE")
          if [ "$ARGS_COUNT" != "0" ] && [ "$ARGS_COUNT" != "null" ]; then
            for i in $(seq 0 $((ARGS_COUNT - 1))); do
              ARG_NAME=$(yq eval ".build.args[$i].name" "$CONFIG_FILE")
              ARG_VALUE=$(yq eval ".build.args[$i].value" "$CONFIG_FILE")
              BUILD_ARGS="${BUILD_ARGS}${ARG_NAME}=${ARG_VALUE},"
            done
          fi
          
          # Set outputs
          echo "name=$NAME" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "repo=$REPO" >> $GITHUB_OUTPUT
          echo "branch=$BRANCH" >> $GITHUB_OUTPUT
          echo "commit=$COMMIT" >> $GITHUB_OUTPUT
          echo "directory=$DIRECTORY" >> $GITHUB_OUTPUT
          echo "dockerfile=$DOCKERFILE" >> $GITHUB_OUTPUT
          echo "debug_mode=$DEBUG_MODE" >> $GITHUB_OUTPUT
          echo "ingress_port=$INGRESS_PORT" >> $GITHUB_OUTPUT
          echo "api_port=$API_PORT" >> $GITHUB_OUTPUT
          echo "aux_api_port=$AUX_API_PORT" >> $GITHUB_OUTPUT
          echo "memory_mb=$MEMORY_MB" >> $GITHUB_OUTPUT
          echo "egress_allow=$EGRESS_ALLOW" >> $GITHUB_OUTPUT
          echo "reproducible_enabled=$REPRODUCIBLE_ENABLED" >> $GITHUB_OUTPUT
          echo "source_date_epoch=$SOURCE_DATE_EPOCH" >> $GITHUB_OUTPUT
          echo "build_args=$BUILD_ARGS" >> $GITHUB_OUTPUT
          echo "description=$DESCRIPTION" >> $GITHUB_OUTPUT
          echo "maintainer=$MAINTAINER" >> $GITHUB_OUTPUT
          echo "license=$LICENSE" >> $GITHUB_OUTPUT
      
      - name: Clone source repository
        id: clone
        run: |
          echo "Cloning repository: ${{ steps.config.outputs.repo }}"
          
          CLONE_DIR="source-repo"
          git clone --branch ${{ steps.config.outputs.branch }} ${{ steps.config.outputs.repo }} "$CLONE_DIR"
          
          cd "$CLONE_DIR"
          
          # Checkout specific commit if specified
          if [ -n "${{ steps.config.outputs.commit }}" ]; then
            git checkout ${{ steps.config.outputs.commit }}
          fi
          
          # Get commit info
          COMMIT_SHA=$(git rev-parse HEAD)
          COMMIT_SHORT=$(git rev-parse --short HEAD)
          COMMIT_TIMESTAMP=$(git log -1 --pretty=%ct)
          COMMIT_MESSAGE=$(git log -1 --pretty=%B | head -1)
          COMMIT_AUTHOR=$(git log -1 --pretty=%an)
          COMMIT_DATE=$(git log -1 --pretty=%ci)
          
          echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
          echo "commit_short=$COMMIT_SHORT" >> $GITHUB_OUTPUT
          echo "commit_timestamp=$COMMIT_TIMESTAMP" >> $GITHUB_OUTPUT
          echo "commit_message=$COMMIT_MESSAGE" >> $GITHUB_OUTPUT
          echo "commit_author=$COMMIT_AUTHOR" >> $GITHUB_OUTPUT
          echo "commit_date=$COMMIT_DATE" >> $GITHUB_OUTPUT
          
          # Verify Dockerfile exists
          DOCKERFILE_PATH="${{ steps.config.outputs.directory }}/${{ steps.config.outputs.dockerfile }}"
          if [ ! -f "$DOCKERFILE_PATH" ]; then
            echo "ERROR: Dockerfile not found at $DOCKERFILE_PATH"
            exit 1
          fi
          
          echo "✅ Source repository cloned successfully"
          echo "   Commit: $COMMIT_SHA"
          echo "   Timestamp: $COMMIT_TIMESTAMP"
      
      - name: Determine SOURCE_DATE_EPOCH
        id: epoch
        run: |
          # Use configured epoch, or fall back to commit timestamp
          if [ -n "${{ steps.config.outputs.source_date_epoch }}" ]; then
            EPOCH="${{ steps.config.outputs.source_date_epoch }}"
            echo "Using configured SOURCE_DATE_EPOCH: $EPOCH"
          else
            EPOCH="${{ steps.clone.outputs.commit_timestamp }}"
            echo "Using commit timestamp as SOURCE_DATE_EPOCH: $EPOCH"
          fi
          echo "epoch=$EPOCH" >> $GITHUB_OUTPUT
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: Create ECR repository if not exists
        run: |
          REPO_NAME="${{ env.ECR_REPOSITORY_PREFIX }}/${{ steps.config.outputs.name }}"
          
          aws ecr describe-repositories --repository-names "$REPO_NAME" 2>/dev/null || \
            aws ecr create-repository --repository-name "$REPO_NAME" --image-scanning-configuration scanOnPush=true
      
      - name: Build application Docker image
        id: build
        run: |
          NAME="${{ steps.config.outputs.name }}"
          VERSION="${{ steps.config.outputs.version }}"
          COMMIT_SHORT="${{ steps.clone.outputs.commit_short }}"
          DIRECTORY="${{ steps.config.outputs.directory }}"
          DOCKERFILE="${{ steps.config.outputs.dockerfile }}"
          SOURCE_DATE_EPOCH="${{ steps.epoch.outputs.epoch }}"
          
          # Local image name (for enclaver to use)
          LOCAL_IMAGE="${NAME}:${VERSION}"
          
          # Build context path
          BUILD_CONTEXT="source-repo/${DIRECTORY}"
          DOCKERFILE_PATH="source-repo/${DIRECTORY}/${DOCKERFILE}"
          
          # Prepare build args for reproducibility
          BUILD_ARGS_FLAGS="--build-arg SOURCE_DATE_EPOCH=${SOURCE_DATE_EPOCH}"
          
          # Add user-defined build args
          USER_ARGS="${{ steps.config.outputs.build_args }}"
          if [ -n "$USER_ARGS" ]; then
            IFS=',' read -ra ARG_ARRAY <<< "$USER_ARGS"
            for arg in "${ARG_ARRAY[@]}"; do
              if [ -n "$arg" ]; then
                BUILD_ARGS_FLAGS="$BUILD_ARGS_FLAGS --build-arg $arg"
              fi
            done
          fi
          
          # Labels for traceability
          LABELS="--label org.opencontainers.image.source=${{ steps.config.outputs.repo }}"
          LABELS="$LABELS --label org.opencontainers.image.revision=${{ steps.clone.outputs.commit_sha }}"
          LABELS="$LABELS --label org.opencontainers.image.version=${VERSION}"
          LABELS="$LABELS --label org.opencontainers.image.created=$(date -u +'%Y-%m-%dT%H:%M:%SZ')"
          LABELS="$LABELS --label org.opencontainers.image.title=${NAME}"
          LABELS="$LABELS --label io.nova.source_date_epoch=${SOURCE_DATE_EPOCH}"
          LABELS="$LABELS --label io.nova.reproducible=true"
          
          echo "Building application Docker image..."
          echo "  SOURCE_DATE_EPOCH: $SOURCE_DATE_EPOCH"
          echo "  Context: $BUILD_CONTEXT"
          echo "  Dockerfile: $DOCKERFILE_PATH"
          
          # Build application image locally
          docker buildx build \
            --platform linux/amd64 \
            --file "$DOCKERFILE_PATH" \
            --tag "${LOCAL_IMAGE}" \
            $LABELS \
            $BUILD_ARGS_FLAGS \
            --provenance=false \
            --sbom=false \
            --load \
            "$BUILD_CONTEXT"
          
          echo "local_image=${LOCAL_IMAGE}" >> $GITHUB_OUTPUT
          
          echo "✅ Application Docker image built successfully"
          echo "   Image: ${LOCAL_IMAGE}"
      
      - name: Install Enclaver CLI
        run: |
          echo "Installing Enclaver CLI..."
          
          /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/sparsity-xyz/enclaver/refs/heads/sparsity/install.sh)"
          
          enclaver --version
          echo "✅ Enclaver CLI installed successfully"
      
      - name: Generate enclaver.yaml
        id: enclaver_config
        run: |
          NAME="${{ steps.config.outputs.name }}"
          VERSION="${{ steps.config.outputs.version }}"
          COMMIT_SHORT="${{ steps.clone.outputs.commit_short }}"
          LOCAL_IMAGE="${{ steps.build.outputs.local_image }}"
          INGRESS_PORT="${{ steps.config.outputs.ingress_port }}"
          API_PORT="${{ steps.config.outputs.api_port }}"
          AUX_API_PORT="${{ steps.config.outputs.aux_api_port }}"
          MEMORY_MB="${{ steps.config.outputs.memory_mb }}"
          
          # ECR release image name
          ECR_IMAGE="${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}/${NAME}"
          RELEASE_IMAGE="${ECR_IMAGE}:${VERSION}-${COMMIT_SHORT}"
          
          mkdir -p output
          
          echo "Generating enclaver.yaml..."
          
          cat > output/enclaver.yaml << EOF
          version: v1
          name: "${NAME}"
          target: "${RELEASE_IMAGE}"
          sources:
            app: "${LOCAL_IMAGE}"
          defaults:
            memory_mb: ${MEMORY_MB}
          ingress:
            - listen_port: ${INGRESS_PORT}
          api:
            listen_port: ${API_PORT}
          aux_api:
            listen_port: ${AUX_API_PORT}
          EOF
          
          # Add egress rules if specified
          EGRESS_ALLOW="${{ steps.config.outputs.egress_allow }}"
          if [ "$EGRESS_ALLOW" != "[]" ] && [ -n "$EGRESS_ALLOW" ]; then
            echo "egress:" >> output/enclaver.yaml
            echo "  allow:" >> output/enclaver.yaml
            # Parse YAML array and add each item
            echo "$EGRESS_ALLOW" | yq eval '.[]' - | while read domain; do
              echo "    - $domain" >> output/enclaver.yaml
            done
          fi
          
          echo "Generated enclaver.yaml:"
          cat output/enclaver.yaml
          
          echo "release_image=${RELEASE_IMAGE}" >> $GITHUB_OUTPUT
          echo "ecr_image=${ECR_IMAGE}" >> $GITHUB_OUTPUT
      
      - name: Build Enclaver release image
        id: enclaver
        run: |
          NAME="${{ steps.config.outputs.name }}"
          VERSION="${{ steps.config.outputs.version }}"
          COMMIT_SHORT="${{ steps.clone.outputs.commit_short }}"
          RELEASE_IMAGE="${{ steps.enclaver_config.outputs.release_image }}"
          ECR_IMAGE="${{ steps.enclaver_config.outputs.ecr_image }}"
          DEBUG_MODE="${{ steps.config.outputs.debug_mode }}"
          
          echo "Building Enclaver release image..."
          echo "  App Name: $NAME"
          echo "  Version: $VERSION"
          echo "  Release Image: $RELEASE_IMAGE"
          echo "  Debug Mode: $DEBUG_MODE"
          
          # Build with enclaver
          cd output
          if [ "$DEBUG_MODE" = "true" ]; then
            echo "Building in DEBUG mode..."
            enclaver build --file enclaver.yaml --eif-only 2>&1 | tee build-output.txt
          else
            enclaver build --file enclaver.yaml --eif-only 2>&1 | tee build-output.txt
          fi
          
          echo "✅ Enclaver build completed"
          
          # Extract PCR values from build output
          echo "Extracting PCR values..."
          PCR0=$(grep -oP 'PCR0:\s*\K[a-f0-9]+' build-output.txt || grep -oP '"PCR0":\s*"\K[^"]+' build-output.txt || echo "")
          PCR1=$(grep -oP 'PCR1:\s*\K[a-f0-9]+' build-output.txt || grep -oP '"PCR1":\s*"\K[^"]+' build-output.txt || echo "")
          PCR2=$(grep -oP 'PCR2:\s*\K[a-f0-9]+' build-output.txt || grep -oP '"PCR2":\s*"\K[^"]+' build-output.txt || echo "")
          
          echo "PCR0: $PCR0"
          echo "PCR1: $PCR1"
          echo "PCR2: $PCR2"
          
          # Create PCR JSON file
          cat > pcr.json << EOF
          {
            "PCR0": "$PCR0",
            "PCR1": "$PCR1",
            "PCR2": "$PCR2"
          }
          EOF
          
          echo "PCR values saved to pcr.json"
          
          # Now build the full release image (with EIF embedded)
          echo "Building full release image..."
          enclaver build --file enclaver.yaml 2>&1 | tee -a build-output.txt
          
          # Push release image to ECR
          echo "Pushing release image to ECR..."
          docker push "${RELEASE_IMAGE}"
          docker tag "${RELEASE_IMAGE}" "${ECR_IMAGE}:${VERSION}"
          docker push "${ECR_IMAGE}:${VERSION}"
          docker tag "${RELEASE_IMAGE}" "${ECR_IMAGE}:latest"
          docker push "${ECR_IMAGE}:latest"
          
          # Get image digest
          DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "${RELEASE_IMAGE}" | cut -d'@' -f2 || echo "")
          
          # Create build info JSON
          cat > build-info.json << EOF
          {
            "app_name": "$NAME",
            "version": "$VERSION",
            "release_image": "${RELEASE_IMAGE}",
            "source_commit": "${{ steps.clone.outputs.commit_sha }}",
            "source_commit_short": "${{ steps.clone.outputs.commit_short }}",
            "source_date_epoch": "${{ steps.epoch.outputs.epoch }}",
            "debug_mode": $DEBUG_MODE,
            "github_run_id": "${{ github.run_id }}",
            "build_timestamp": "$(date -u +'%Y-%m-%dT%H:%M:%SZ')",
            "pcr": {
              "PCR0": "$PCR0",
              "PCR1": "$PCR1",
              "PCR2": "$PCR2"
            }
          }
          EOF
          
          echo "Build info saved to build-info.json"
          cat build-info.json
          
          # Set outputs
          echo "release_image=${RELEASE_IMAGE}" >> $GITHUB_OUTPUT
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT
          echo "pcr0=$PCR0" >> $GITHUB_OUTPUT
          echo "pcr1=$PCR1" >> $GITHUB_OUTPUT
          echo "pcr2=$PCR2" >> $GITHUB_OUTPUT
          
          echo "✅ Release image pushed successfully"
          echo "   Image: ${RELEASE_IMAGE}"
          echo "   Digest: $DIGEST"
      
      - name: Upload artifacts to S3
        run: |
          APP_NAME="${{ steps.config.outputs.name }}"
          VERSION="${{ steps.config.outputs.version }}"
          
          echo "Uploading artifacts to S3..."
          aws s3 cp output/pcr.json "s3://${{ env.S3_BUCKET }}/builds/${APP_NAME}/${VERSION}/pcr.json"
          aws s3 cp output/build-info.json "s3://${{ env.S3_BUCKET }}/builds/${APP_NAME}/${VERSION}/build-info.json"
          aws s3 cp output/build-output.txt "s3://${{ env.S3_BUCKET }}/builds/${APP_NAME}/${VERSION}/build-output.txt"
          aws s3 cp output/enclaver.yaml "s3://${{ env.S3_BUCKET }}/builds/${APP_NAME}/${VERSION}/enclaver.yaml"
          
          echo "✅ Artifacts uploaded successfully"
          echo "  PCR: s3://${{ env.S3_BUCKET }}/builds/${APP_NAME}/${VERSION}/pcr.json"
      
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.config.outputs.name }}-v${{ steps.config.outputs.version }}
          name: "${{ steps.config.outputs.name }} v${{ steps.config.outputs.version }}"
          body: |
            ## AWS Nitro Enclave Build (via Enclaver)
            
            - **Application**: ${{ steps.config.outputs.name }}
            - **Version**: ${{ steps.config.outputs.version }}
            - **Build Time**: ${{ github.event.head_commit.timestamp }}
            - **Build Number**: ${{ github.run_number }}
            
            ## Source
            
            - **Repository**: ${{ steps.config.outputs.repo }}
            - **Branch**: ${{ steps.config.outputs.branch }}
            - **Commit**: `${{ steps.clone.outputs.commit_sha }}`
            - **Commit Message**: ${{ steps.clone.outputs.commit_message }}
            - **SOURCE_DATE_EPOCH**: `${{ steps.epoch.outputs.epoch }}`
            
            ## Build Settings
            
            | Setting | Value |
            |---------|-------|
            | Debug Mode | ${{ steps.config.outputs.debug_mode }} |
            | Memory (MB) | ${{ steps.config.outputs.memory_mb }} |
            
            ## PCR Values (Platform Configuration Registers)
            
            These values can be used for remote attestation to verify the enclave identity.
            
            | PCR | Value |
            |-----|-------|
            | **PCR0** | `${{ steps.enclaver.outputs.pcr0 }}` |
            | **PCR1** | `${{ steps.enclaver.outputs.pcr1 }}` |
            | **PCR2** | `${{ steps.enclaver.outputs.pcr2 }}` |
            
            ## Release Docker Image
            
            The release image contains the EIF and Enclaver runtime:
            
            ```
            ${{ steps.enclaver.outputs.release_image }}
            ```
            
            **Digest**: `${{ steps.enclaver.outputs.digest }}`
            
            ## Usage
            
            Run on an EC2 instance with Nitro Enclave support:
            
            ```bash
            docker pull ${{ steps.enclaver.outputs.release_image }}
            docker run --rm --privileged ${{ steps.enclaver.outputs.release_image }}
            ```
            
            ## Verification
            
            To verify this build:
            
            1. Check the [GitHub Actions run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
            2. Verify PCR values match the expected values for your attestation policy
            3. The build is reproducible - rebuilding from the same commit with the same SOURCE_DATE_EPOCH should produce identical PCR values
          draft: false
          prerelease: false
          files: |
            output/pcr.json
            output/build-info.json
            output/enclaver.yaml
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Update build info
        run: |
          APP_NAME="${{ steps.config.outputs.name }}"
          VERSION="${{ steps.config.outputs.version }}"
          BUILD_INFO_FILE="apps/${{ matrix.app }}/BUILD_INFO.md"
          
          cat > "$BUILD_INFO_FILE" << EOF
          # Build Information
          
          > This file is auto-generated. Do not edit manually.
          
          ## Latest Build
          
          | Property | Value |
          |----------|-------|
          | **Version** | ${VERSION} |
          | **Build Time** | $(date -u +'%Y-%m-%dT%H:%M:%SZ') |
          | **Build Number** | ${{ github.run_number }} |
          | **Source Commit** | \`${{ steps.clone.outputs.commit_short }}\` |
          | **SOURCE_DATE_EPOCH** | \`${{ steps.epoch.outputs.epoch }}\` |
          
          ## PCR Values
          
          | PCR | Value |
          |-----|-------|
          | **PCR0** | \`${{ steps.enclaver.outputs.pcr0 }}\` |
          | **PCR1** | \`${{ steps.enclaver.outputs.pcr1 }}\` |
          | **PCR2** | \`${{ steps.enclaver.outputs.pcr2 }}\` |
          
          ## Release Docker Image
          
          \`\`\`
          ${{ steps.enclaver.outputs.release_image }}
          \`\`\`
          
          **Digest**: \`${{ steps.enclaver.outputs.digest }}\`
          
          ## Artifacts
          
          - **S3**: \`s3://${{ env.S3_BUCKET }}/builds/${APP_NAME}/${VERSION}/\`
          - **GitHub Release**: [${APP_NAME}-v${VERSION}](https://github.com/${{ github.repository }}/releases/tag/${APP_NAME}-v${VERSION})
          
          ## Verification
          
          To verify this build, check the [GitHub Actions run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}).
          EOF
          
          echo "✅ Build info updated"
      
      - name: Commit build info
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "chore: update build info for ${{ steps.config.outputs.name }} v${{ steps.config.outputs.version }}"
          file_pattern: "apps/${{ matrix.app }}/BUILD_INFO.md"
      
      - name: Summary
        run: |
          echo "## Build Summary for ${{ steps.config.outputs.name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "✅ **Build Successful!**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Application Info" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Name | ${{ steps.config.outputs.name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Version | ${{ steps.config.outputs.version }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Source Commit | \`${{ steps.clone.outputs.commit_short }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| SOURCE_DATE_EPOCH | \`${{ steps.epoch.outputs.epoch }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### PCR Values" >> $GITHUB_STEP_SUMMARY
          echo "| PCR | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-----|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| PCR0 | \`${{ steps.enclaver.outputs.pcr0 }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| PCR1 | \`${{ steps.enclaver.outputs.pcr1 }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| PCR2 | \`${{ steps.enclaver.outputs.pcr2 }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Release Image" >> $GITHUB_STEP_SUMMARY
          echo "| Type | Location |" >> $GITHUB_STEP_SUMMARY
          echo "|------|----------|" >> $GITHUB_STEP_SUMMARY
          echo "| Release Image | \`${{ steps.enclaver.outputs.release_image }}\` |" >> $GITHUB_STEP_SUMMARY
