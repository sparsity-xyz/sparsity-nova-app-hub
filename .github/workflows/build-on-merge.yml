# Nova App Hub - Build on Merge Workflow
# Builds Docker image and creates Enclaver release image with embedded EIF

name: Build and Publish

on:
  # Only triggered via API from Nova Platform (no push trigger)
  workflow_dispatch:
    inputs:
      app_dir:
        description: 'App directory name to build (e.g., 123-hn-fetcher)'
        required: true
        type: string
      app_id:
        description: 'App ID from Nova Platform (for callback)'
        required: false
        type: string
      build_id:
        description: 'Build ID from Nova Platform (for callback)'
        required: false
        type: string

env:
  # AWS Configuration (from CloudFormation stack outputs)
  AWS_REGION: us-west-1
  ECR_REGISTRY: 004118891089.dkr.ecr.us-west-1.amazonaws.com
  ECR_REPOSITORY_PREFIX: nova-apps
  S3_BUCKET: nova-app-hub-artifacts-004118891089

jobs:
  detect-changes:
    name: Detect Changed Apps
    runs-on: ubuntu-latest
    outputs:
      apps: ${{ steps.detect.outputs.apps }}
      has_changes: ${{ steps.detect.outputs.has_changes }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2
      
      - name: Detect changed apps
        id: detect
        run: |
          # Check if manually triggered with app_dir input
          if [ -n "${{ github.event.inputs.app_dir }}" ]; then
            APP_DIR="${{ github.event.inputs.app_dir }}"
            echo "Manual trigger for app: $APP_DIR"
            
            # Verify the app exists
            if [ -f "apps/$APP_DIR/nova-build.yaml" ]; then
              echo "apps=[\"$APP_DIR\"]" >> $GITHUB_OUTPUT
              echo "has_changes=true" >> $GITHUB_OUTPUT
            else
              echo "ERROR: App not found: apps/$APP_DIR/nova-build.yaml"
              exit 1
            fi
          else
            # Auto-detect from git diff (push trigger)
            CHANGED_FILES=$(git diff --name-only HEAD^ HEAD -- 'apps/')
            
            echo "Changed files:"
            echo "$CHANGED_FILES"
            
            # Extract unique app directories (exclude _example)
            APPS=()
            for file in $CHANGED_FILES; do
              if [[ "$file" =~ ^apps/([^/]+)/nova-build\.yaml$ ]]; then
                APP_NAME="${BASH_REMATCH[1]}"
                # Skip example directory
                if [ "$APP_NAME" != "_example" ]; then
                  if [[ ! " ${APPS[@]} " =~ " ${APP_NAME} " ]]; then
                    APPS+=("$APP_NAME")
                  fi
                fi
              fi
            done
            
            if [ ${#APPS[@]} -eq 0 ]; then
              echo "No app changes detected"
              echo "has_changes=false" >> $GITHUB_OUTPUT
              echo "apps=[]" >> $GITHUB_OUTPUT
            else
              echo "Apps to build: ${APPS[*]}"
              JSON_APPS=$(printf '%s\n' "${APPS[@]}" | jq -R . | jq -s -c .)
              echo "apps=$JSON_APPS" >> $GITHUB_OUTPUT
              echo "has_changes=true" >> $GITHUB_OUTPUT
            fi
          fi

  build:
    name: Build - ${{ matrix.app }}
    needs: detect-changes
    if: needs.detect-changes.outputs.has_changes == 'true'
    runs-on: ubuntu-latest
    
    # Permissions required for SLSA provenance and keyless signing
    permissions:
      contents: write      # For creating releases and committing BUILD_INFO.md
      packages: write      # For pushing to container registry
      id-token: write      # Required for OIDC/keyless signing via Sigstore
    
    strategy:
      fail-fast: false
      matrix:
        app: ${{ fromJson(needs.detect-changes.outputs.apps) }}
    
    outputs:
      image_uri: ${{ steps.enclaver.outputs.release_image }}
      image_digest: ${{ steps.enclaver.outputs.digest }}
      rekor_log_index: ${{ steps.sign.outputs.rekor_index }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
      
      - name: Parse build configuration
        id: config
        run: |
          CONFIG_FILE="apps/${{ matrix.app }}/nova-build.yaml"
          
          echo "Parsing configuration from: $CONFIG_FILE"
          
          # Extract configuration values
          NAME=$(yq eval '.name' "$CONFIG_FILE")
          VERSION=$(yq eval '.version' "$CONFIG_FILE")
          REPO=$(yq eval '.repo' "$CONFIG_FILE")
          BRANCH=$(yq eval '.branch' "$CONFIG_FILE")
          COMMIT=$(yq eval '.commit // ""' "$CONFIG_FILE")
          DIRECTORY=$(yq eval '.build.directory // "."' "$CONFIG_FILE")
          DOCKERFILE=$(yq eval '.build.dockerfile // "Dockerfile"' "$CONFIG_FILE")
          
          # Enclave configuration (build-time only)
          DEBUG_MODE=$(yq eval '.enclave.debug_mode // false' "$CONFIG_FILE")
          
          # Enclaver configuration
          INGRESS_PORT=$(yq eval '.enclaver.ingress_port // 8000' "$CONFIG_FILE")
          API_PORT=$(yq eval '.enclaver.api_port // 9000' "$CONFIG_FILE")
          AUX_API_PORT=$(yq eval '.enclaver.aux_api_port // 9001' "$CONFIG_FILE")
          MEMORY_MB=$(yq eval '.enclaver.memory_mb // 1500' "$CONFIG_FILE")
          EGRESS_ALLOW=$(yq eval '.enclaver.egress_allow // []' "$CONFIG_FILE")
          
          # Reproducible build settings
          REPRODUCIBLE_ENABLED=$(yq eval '.reproducible.enabled // true' "$CONFIG_FILE")
          SOURCE_DATE_EPOCH=$(yq eval '.reproducible.source_date_epoch // ""' "$CONFIG_FILE")
          
          # Metadata
          DESCRIPTION=$(yq eval '.metadata.description // ""' "$CONFIG_FILE")
          MAINTAINER=$(yq eval '.metadata.maintainer // ""' "$CONFIG_FILE")
          LICENSE=$(yq eval '.metadata.license // ""' "$CONFIG_FILE")
          
          # Parse build args
          BUILD_ARGS=""
          ARGS_COUNT=$(yq eval '.build.args | length' "$CONFIG_FILE")
          if [ "$ARGS_COUNT" != "0" ] && [ "$ARGS_COUNT" != "null" ]; then
            for i in $(seq 0 $((ARGS_COUNT - 1))); do
              ARG_NAME=$(yq eval ".build.args[$i].name" "$CONFIG_FILE")
              ARG_VALUE=$(yq eval ".build.args[$i].value" "$CONFIG_FILE")
              BUILD_ARGS="${BUILD_ARGS}${ARG_NAME}=${ARG_VALUE},"
            done
          fi
          
          # Set outputs
          echo "name=$NAME" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "repo=$REPO" >> $GITHUB_OUTPUT
          echo "branch=$BRANCH" >> $GITHUB_OUTPUT
          echo "commit=$COMMIT" >> $GITHUB_OUTPUT
          echo "directory=$DIRECTORY" >> $GITHUB_OUTPUT
          echo "dockerfile=$DOCKERFILE" >> $GITHUB_OUTPUT
          echo "debug_mode=$DEBUG_MODE" >> $GITHUB_OUTPUT
          echo "ingress_port=$INGRESS_PORT" >> $GITHUB_OUTPUT
          echo "api_port=$API_PORT" >> $GITHUB_OUTPUT
          echo "aux_api_port=$AUX_API_PORT" >> $GITHUB_OUTPUT
          echo "memory_mb=$MEMORY_MB" >> $GITHUB_OUTPUT
          echo "egress_allow=$EGRESS_ALLOW" >> $GITHUB_OUTPUT
          echo "reproducible_enabled=$REPRODUCIBLE_ENABLED" >> $GITHUB_OUTPUT
          echo "source_date_epoch=$SOURCE_DATE_EPOCH" >> $GITHUB_OUTPUT
          echo "build_args=$BUILD_ARGS" >> $GITHUB_OUTPUT
          echo "description=$DESCRIPTION" >> $GITHUB_OUTPUT
          echo "maintainer=$MAINTAINER" >> $GITHUB_OUTPUT
          echo "license=$LICENSE" >> $GITHUB_OUTPUT
      
      - name: Clone source repository
        id: clone
        run: |
          echo "Cloning repository: ${{ steps.config.outputs.repo }}"
          
          CLONE_DIR="source-repo"
          git clone --branch ${{ steps.config.outputs.branch }} ${{ steps.config.outputs.repo }} "$CLONE_DIR"
          
          cd "$CLONE_DIR"
          
          # Checkout specific commit if specified
          if [ -n "${{ steps.config.outputs.commit }}" ]; then
            git checkout ${{ steps.config.outputs.commit }}
          fi
          
          # Get commit info
          COMMIT_SHA=$(git rev-parse HEAD)
          COMMIT_SHORT=$(git rev-parse --short HEAD)
          COMMIT_TIMESTAMP=$(git log -1 --pretty=%ct)
          COMMIT_MESSAGE=$(git log -1 --pretty=%B | head -1)
          COMMIT_AUTHOR=$(git log -1 --pretty=%an)
          COMMIT_DATE=$(git log -1 --pretty=%ci)
          
          echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
          echo "commit_short=$COMMIT_SHORT" >> $GITHUB_OUTPUT
          echo "commit_timestamp=$COMMIT_TIMESTAMP" >> $GITHUB_OUTPUT
          echo "commit_message=$COMMIT_MESSAGE" >> $GITHUB_OUTPUT
          echo "commit_author=$COMMIT_AUTHOR" >> $GITHUB_OUTPUT
          echo "commit_date=$COMMIT_DATE" >> $GITHUB_OUTPUT
          
          # Verify Dockerfile exists
          DOCKERFILE_PATH="${{ steps.config.outputs.directory }}/${{ steps.config.outputs.dockerfile }}"
          if [ ! -f "$DOCKERFILE_PATH" ]; then
            echo "ERROR: Dockerfile not found at $DOCKERFILE_PATH"
            exit 1
          fi
          
          echo "✅ Source repository cloned successfully"
          echo "   Commit: $COMMIT_SHA"
          echo "   Timestamp: $COMMIT_TIMESTAMP"
      
      - name: Determine SOURCE_DATE_EPOCH
        id: epoch
        run: |
          # Use configured epoch, or fall back to commit timestamp
          if [ -n "${{ steps.config.outputs.source_date_epoch }}" ]; then
            EPOCH="${{ steps.config.outputs.source_date_epoch }}"
            echo "Using configured SOURCE_DATE_EPOCH: $EPOCH"
          else
            EPOCH="${{ steps.clone.outputs.commit_timestamp }}"
            echo "Using commit timestamp as SOURCE_DATE_EPOCH: $EPOCH"
          fi
          echo "epoch=$EPOCH" >> $GITHUB_OUTPUT
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: Create ECR repository if not exists
        run: |
          REPO_NAME="${{ env.ECR_REPOSITORY_PREFIX }}/${{ steps.config.outputs.name }}"
          
          aws ecr describe-repositories --repository-names "$REPO_NAME" 2>/dev/null || \
            aws ecr create-repository --repository-name "$REPO_NAME" --image-scanning-configuration scanOnPush=true
      
      - name: Build application Docker image
        id: build
        run: |
          NAME="${{ steps.config.outputs.name }}"
          VERSION="${{ steps.config.outputs.version }}"
          COMMIT_SHORT="${{ steps.clone.outputs.commit_short }}"
          DIRECTORY="${{ steps.config.outputs.directory }}"
          DOCKERFILE="${{ steps.config.outputs.dockerfile }}"
          SOURCE_DATE_EPOCH="${{ steps.epoch.outputs.epoch }}"
          
          # Local image name (for enclaver to use)
          LOCAL_IMAGE="${NAME}:${VERSION}"
          
          # Build context path
          BUILD_CONTEXT="source-repo/${DIRECTORY}"
          DOCKERFILE_PATH="source-repo/${DIRECTORY}/${DOCKERFILE}"
          
          # Prepare build args for reproducibility
          BUILD_ARGS_FLAGS="--build-arg SOURCE_DATE_EPOCH=${SOURCE_DATE_EPOCH}"
          
          # Add user-defined build args
          USER_ARGS="${{ steps.config.outputs.build_args }}"
          if [ -n "$USER_ARGS" ]; then
            IFS=',' read -ra ARG_ARRAY <<< "$USER_ARGS"
            for arg in "${ARG_ARRAY[@]}"; do
              if [ -n "$arg" ]; then
                BUILD_ARGS_FLAGS="$BUILD_ARGS_FLAGS --build-arg $arg"
              fi
            done
          fi
          
          # Labels for traceability
          LABELS="--label org.opencontainers.image.source=${{ steps.config.outputs.repo }}"
          LABELS="$LABELS --label org.opencontainers.image.revision=${{ steps.clone.outputs.commit_sha }}"
          LABELS="$LABELS --label org.opencontainers.image.version=${VERSION}"
          LABELS="$LABELS --label org.opencontainers.image.created=$(date -u +'%Y-%m-%dT%H:%M:%SZ')"
          LABELS="$LABELS --label org.opencontainers.image.title=${NAME}"
          LABELS="$LABELS --label io.nova.source_date_epoch=${SOURCE_DATE_EPOCH}"
          LABELS="$LABELS --label io.nova.reproducible=true"
          
          echo "Building application Docker image..."
          echo "  SOURCE_DATE_EPOCH: $SOURCE_DATE_EPOCH"
          echo "  Context: $BUILD_CONTEXT"
          echo "  Dockerfile: $DOCKERFILE_PATH"
          
          # Build application image locally
          docker buildx build \
            --platform linux/amd64 \
            --file "$DOCKERFILE_PATH" \
            --tag "${LOCAL_IMAGE}" \
            $LABELS \
            $BUILD_ARGS_FLAGS \
            --provenance=false \
            --sbom=false \
            --load \
            "$BUILD_CONTEXT"
          
          echo "local_image=${LOCAL_IMAGE}" >> $GITHUB_OUTPUT
          
          echo "✅ Application Docker image built successfully"
          echo "   Image: ${LOCAL_IMAGE}"
      
      - name: Install Cosign
        uses: sigstore/cosign-installer@v3.7.0
      
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
        continue-on-error: true  # Continue even if Docker Hub login fails
      
      - name: Install Enclaver CLI
        run: |
          echo "Installing Enclaver CLI..."
          
          /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/sparsity-xyz/enclaver/refs/heads/sparsity/install.sh)"
          
          enclaver --version
          echo "✅ Enclaver CLI installed successfully"
      
      - name: Generate enclaver.yaml
        id: enclaver_config
        run: |
          NAME="${{ steps.config.outputs.name }}"
          VERSION="${{ steps.config.outputs.version }}"
          COMMIT_SHORT="${{ steps.clone.outputs.commit_short }}"
          LOCAL_IMAGE="${{ steps.build.outputs.local_image }}"
          INGRESS_PORT="${{ steps.config.outputs.ingress_port }}"
          API_PORT="${{ steps.config.outputs.api_port }}"
          AUX_API_PORT="${{ steps.config.outputs.aux_api_port }}"
          MEMORY_MB="${{ steps.config.outputs.memory_mb }}"
          
          # ECR release image name
          ECR_IMAGE="${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}/${NAME}"
          RELEASE_IMAGE="${ECR_IMAGE}:${VERSION}-${COMMIT_SHORT}"
          
          mkdir -p output
          
          echo "Generating enclaver.yaml..."
          
          cat > output/enclaver.yaml << EOF
          version: v1
          name: "${NAME}"
          target: "${RELEASE_IMAGE}"
          sources:
            app: "${LOCAL_IMAGE}"
          defaults:
            memory_mb: ${MEMORY_MB}
          ingress:
            - listen_port: ${INGRESS_PORT}
          api:
            listen_port: ${API_PORT}
          aux_api:
            listen_port: ${AUX_API_PORT}
          EOF
          
          # Add egress rules if specified
          EGRESS_ALLOW="${{ steps.config.outputs.egress_allow }}"
          if [ "$EGRESS_ALLOW" != "[]" ] && [ -n "$EGRESS_ALLOW" ]; then
            echo "egress:" >> output/enclaver.yaml
            echo "  allow:" >> output/enclaver.yaml
            # Parse YAML array and add each item
            echo "$EGRESS_ALLOW" | yq eval '.[]' - | while read domain; do
              echo "    - $domain" >> output/enclaver.yaml
            done
          fi
          
          echo "Generated enclaver.yaml:"
          cat output/enclaver.yaml
          
          echo "release_image=${RELEASE_IMAGE}" >> $GITHUB_OUTPUT
          echo "ecr_image=${ECR_IMAGE}" >> $GITHUB_OUTPUT
      
      - name: Build Enclaver release image
        id: enclaver
        run: |
          NAME="${{ steps.config.outputs.name }}"
          VERSION="${{ steps.config.outputs.version }}"
          COMMIT_SHORT="${{ steps.clone.outputs.commit_short }}"
          RELEASE_IMAGE="${{ steps.enclaver_config.outputs.release_image }}"
          ECR_IMAGE="${{ steps.enclaver_config.outputs.ecr_image }}"
          DEBUG_MODE="${{ steps.config.outputs.debug_mode }}"
          
          echo "Building Enclaver release image..."
          echo "  App Name: $NAME"
          echo "  Version: $VERSION"
          echo "  Release Image: $RELEASE_IMAGE"
          echo "  Debug Mode: $DEBUG_MODE"
          
          # Build with enclaver (produces release image with embedded EIF)
          cd output
          enclaver build --file enclaver.yaml 2>&1 | tee build-output.txt
          
          echo "✅ Enclaver build completed"
          
          # Extract PCR values from build output
          echo "Extracting PCR values..."
          PCR0=$(grep -oP 'PCR0:\s*\K[a-f0-9]+' build-output.txt || grep -oP '"PCR0":\s*"\K[^"]+' build-output.txt || echo "")
          PCR1=$(grep -oP 'PCR1:\s*\K[a-f0-9]+' build-output.txt || grep -oP '"PCR1":\s*"\K[^"]+' build-output.txt || echo "")
          PCR2=$(grep -oP 'PCR2:\s*\K[a-f0-9]+' build-output.txt || grep -oP '"PCR2":\s*"\K[^"]+' build-output.txt || echo "")
          
          echo "PCR0: $PCR0"
          echo "PCR1: $PCR1"
          echo "PCR2: $PCR2"
          
          # Create PCR JSON file
          cat > pcr.json << EOF
          {
            "PCR0": "$PCR0",
            "PCR1": "$PCR1",
            "PCR2": "$PCR2"
          }
          EOF
          
          echo "PCR values saved to pcr.json"
          
          # Push release image to ECR
          echo "Pushing release image to ECR..."
          docker push "${RELEASE_IMAGE}"
          docker tag "${RELEASE_IMAGE}" "${ECR_IMAGE}:${VERSION}"
          docker push "${ECR_IMAGE}:${VERSION}"
          docker tag "${RELEASE_IMAGE}" "${ECR_IMAGE}:latest"
          docker push "${ECR_IMAGE}:latest"
          
          # Get image digest
          DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "${RELEASE_IMAGE}" | cut -d'@' -f2 || echo "")
          
          # Set outputs (before signing so they're available)
          echo "release_image=${RELEASE_IMAGE}" >> $GITHUB_OUTPUT
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT
          echo "pcr0=$PCR0" >> $GITHUB_OUTPUT
          echo "pcr1=$PCR1" >> $GITHUB_OUTPUT
          echo "pcr2=$PCR2" >> $GITHUB_OUTPUT
          
          echo "✅ Release image pushed successfully"
          echo "   Image: ${RELEASE_IMAGE}"
          echo "   Digest: $DIGEST"
      
      - name: Sign container image (keyless via Sigstore)
        id: sign
        run: |
          RELEASE_IMAGE="${{ steps.enclaver.outputs.release_image }}"
          DIGEST="${{ steps.enclaver.outputs.digest }}"
          
          echo "Signing container image with cosign (keyless)..."
          echo "  Image: ${RELEASE_IMAGE}"
          echo "  Digest: ${DIGEST}"
          
          # Sign the image using keyless signing via Sigstore Fulcio
          cosign sign --yes "${RELEASE_IMAGE}@${DIGEST}"
          
          echo "✅ Image signed successfully"
          
          # Verify the signature and extract Rekor log index
          echo "Verifying signature..."
          VERIFY_OUTPUT=$(cosign verify \
            --certificate-identity-regexp='https://github.com/${{ github.repository }}/.*' \
            --certificate-oidc-issuer='https://token.actions.githubusercontent.com' \
            "${RELEASE_IMAGE}@${DIGEST}" 2>&1) || true
          
          echo "$VERIFY_OUTPUT"
          
          # Extract Rekor log index from verification output
          REKOR_INDEX=$(echo "$VERIFY_OUTPUT" | grep -oP '"logIndex":\s*\K\d+' | head -1 || echo "")
          
          echo "rekor_index=$REKOR_INDEX" >> $GITHUB_OUTPUT
          echo "✅ Signature verified - Rekor log index: $REKOR_INDEX"
      
      - name: Generate unified build metadata
        id: metadata
        run: |
          NAME="${{ steps.config.outputs.name }}"
          VERSION="${{ steps.config.outputs.version }}"
          RELEASE_IMAGE="${{ steps.enclaver.outputs.release_image }}"
          DIGEST="${{ steps.enclaver.outputs.digest }}"
          PCR0="${{ steps.enclaver.outputs.pcr0 }}"
          PCR1="${{ steps.enclaver.outputs.pcr1 }}"
          PCR2="${{ steps.enclaver.outputs.pcr2 }}"
          REKOR_INDEX="${{ steps.sign.outputs.rekor_index }}"
          
          cd output
          
          # Create unified build-metadata.json
          cat > build-metadata.json << EOF
          {
            "schema_version": "1.0",
            "app_name": "$NAME",
            "version": "$VERSION",
            "image_uri": "${RELEASE_IMAGE}",
            "image_digest": "${DIGEST}",
            "source_repo": "${{ steps.config.outputs.repo }}",
            "source_branch": "${{ steps.config.outputs.branch }}",
            "source_commit": "${{ steps.clone.outputs.commit_sha }}",
            "source_commit_short": "${{ steps.clone.outputs.commit_short }}",
            "source_date_epoch": "${{ steps.epoch.outputs.epoch }}",
            "build_timestamp": "$(date -u +'%Y-%m-%dT%H:%M:%SZ')",
            "github_run_id": "${{ github.run_id }}",
            "github_run_number": "${{ github.run_number }}",
            "debug_mode": ${{ steps.config.outputs.debug_mode }},
            "pcr": {
              "PCR0": "$PCR0",
              "PCR1": "$PCR1",
              "PCR2": "$PCR2"
            },
            "slsa": {
              "signed": true,
              "rekor_log_index": "$REKOR_INDEX",
              "certificate_issuer": "https://token.actions.githubusercontent.com",
              "certificate_identity": "https://github.com/${{ github.repository }}/.github/workflows/build-on-merge.yml@${{ github.ref }}",
              "verification_command": "cosign verify --certificate-identity-regexp='https://github.com/${{ github.repository }}/.*' --certificate-oidc-issuer='https://token.actions.githubusercontent.com' ${RELEASE_IMAGE}@${DIGEST}"
            }
          }
          EOF
          
          echo "Build metadata saved to build-metadata.json"
          cat build-metadata.json
      
      - name: Upload artifacts to S3
        run: |
          APP_NAME="${{ steps.config.outputs.name }}"
          VERSION="${{ steps.config.outputs.version }}"
          
          echo "Uploading artifacts to S3..."
          aws s3 cp output/pcr.json "s3://${{ env.S3_BUCKET }}/builds/${APP_NAME}/${VERSION}/pcr.json"
          aws s3 cp output/build-metadata.json "s3://${{ env.S3_BUCKET }}/builds/${APP_NAME}/${VERSION}/build-metadata.json"
          aws s3 cp output/build-output.txt "s3://${{ env.S3_BUCKET }}/builds/${APP_NAME}/${VERSION}/build-output.txt"
          aws s3 cp output/enclaver.yaml "s3://${{ env.S3_BUCKET }}/builds/${APP_NAME}/${VERSION}/enclaver.yaml"
          
          echo "✅ Artifacts uploaded successfully"
          echo "  PCR: s3://${{ env.S3_BUCKET }}/builds/${APP_NAME}/${VERSION}/pcr.json"
          echo "  Metadata: s3://${{ env.S3_BUCKET }}/builds/${APP_NAME}/${VERSION}/build-metadata.json"
      
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.config.outputs.name }}-v${{ steps.config.outputs.version }}
          name: "${{ steps.config.outputs.name }} v${{ steps.config.outputs.version }}"
          body: |
            ## AWS Nitro Enclave Build (via Enclaver)
            
            - **Application**: ${{ steps.config.outputs.name }}
            - **Version**: ${{ steps.config.outputs.version }}
            - **Build Time**: ${{ github.event.head_commit.timestamp }}
            - **Build Number**: ${{ github.run_number }}
            
            ## Source
            
            - **Repository**: ${{ steps.config.outputs.repo }}
            - **Branch**: ${{ steps.config.outputs.branch }}
            - **Commit**: `${{ steps.clone.outputs.commit_sha }}`
            - **Commit Message**: ${{ steps.clone.outputs.commit_message }}
            - **SOURCE_DATE_EPOCH**: `${{ steps.epoch.outputs.epoch }}`
            
            ## Build Settings
            
            | Setting | Value |
            |---------|-------|
            | Debug Mode | ${{ steps.config.outputs.debug_mode }} |
            | Memory (MB) | ${{ steps.config.outputs.memory_mb }} |
            
            ## PCR Values (Platform Configuration Registers)
            
            These values can be used for remote attestation to verify the enclave identity.
            
            | PCR | Value |
            |-----|-------|
            | **PCR0** | `${{ steps.enclaver.outputs.pcr0 }}` |
            | **PCR1** | `${{ steps.enclaver.outputs.pcr1 }}` |
            | **PCR2** | `${{ steps.enclaver.outputs.pcr2 }}` |
            
            ## Release Docker Image
            
            The release image contains the EIF and Enclaver runtime:
            
            ```
            ${{ steps.enclaver.outputs.release_image }}
            ```
            
            **Digest**: `${{ steps.enclaver.outputs.digest }}`
            
            ## SLSA Provenance & Signature Verification
            
            This image is signed using [Sigstore cosign](https://sigstore.dev) with keyless signing.
            
            **Rekor Log Index**: `${{ steps.sign.outputs.rekor_index }}`
            
            ### Verify Signature
            
            ```bash
            cosign verify \
              --certificate-identity-regexp='https://github.com/${{ github.repository }}/.*' \
              --certificate-oidc-issuer='https://token.actions.githubusercontent.com' \
              ${{ steps.enclaver.outputs.release_image }}@${{ steps.enclaver.outputs.digest }}
            ```
            
            ## Usage
            
            Run on an EC2 instance with Nitro Enclave support:
            
            ```bash
            docker pull ${{ steps.enclaver.outputs.release_image }}
            docker run --rm --privileged ${{ steps.enclaver.outputs.release_image }}
            ```
            
            ## Verification
            
            To verify this build:
            
            1. Check the [GitHub Actions run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
            2. Verify PCR values match the expected values for your attestation policy
            3. Verify the container signature using cosign (see above)
            4. The build is reproducible - rebuilding from the same commit with the same SOURCE_DATE_EPOCH should produce identical PCR values
          draft: false
          prerelease: false
          files: |
            output/pcr.json
            output/build-metadata.json
            output/enclaver.yaml
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Update build info
        run: |
          APP_NAME="${{ steps.config.outputs.name }}"
          VERSION="${{ steps.config.outputs.version }}"
          BUILD_INFO_FILE="apps/${{ matrix.app }}/BUILD_INFO.md"
          
          cat > "$BUILD_INFO_FILE" << EOF
          # Build Information
          
          > This file is auto-generated. Do not edit manually.
          
          ## Latest Build
          
          | Property | Value |
          |----------|-------|
          | **Version** | ${VERSION} |
          | **Build Time** | $(date -u +'%Y-%m-%dT%H:%M:%SZ') |
          | **Build Number** | ${{ github.run_number }} |
          | **Source Commit** | \`${{ steps.clone.outputs.commit_short }}\` |
          | **SOURCE_DATE_EPOCH** | \`${{ steps.epoch.outputs.epoch }}\` |
          
          ## PCR Values
          
          | PCR | Value |
          |-----|-------|
          | **PCR0** | \`${{ steps.enclaver.outputs.pcr0 }}\` |
          | **PCR1** | \`${{ steps.enclaver.outputs.pcr1 }}\` |
          | **PCR2** | \`${{ steps.enclaver.outputs.pcr2 }}\` |
          
          ## Release Docker Image
          
          \`\`\`
          ${{ steps.enclaver.outputs.release_image }}
          \`\`\`
          
          **Digest**: \`${{ steps.enclaver.outputs.digest }}\`
          
          ## Artifacts
          
          - **S3**: \`s3://${{ env.S3_BUCKET }}/builds/${APP_NAME}/${VERSION}/\`
          - **GitHub Release**: [${APP_NAME}-v${VERSION}](https://github.com/${{ github.repository }}/releases/tag/${APP_NAME}-v${VERSION})
          
          ## Verification
          
          To verify this build, check the [GitHub Actions run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}).
          EOF
          
          echo "✅ Build info updated"
      
      - name: Pull latest changes before commit
        run: |
          # Pull latest changes to avoid conflicts with commits made by Nova Platform API
          git fetch origin main
          git rebase origin/main || git merge origin/main --no-edit
      
      - name: Commit build info
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "chore: update build info for ${{ steps.config.outputs.name }} v${{ steps.config.outputs.version }}"
          file_pattern: "apps/${{ matrix.app }}/BUILD_INFO.md"
      
      - name: Summary
        run: |
          echo "## Build Summary for ${{ steps.config.outputs.name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "✅ **Build Successful!**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Application Info" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Name | ${{ steps.config.outputs.name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Version | ${{ steps.config.outputs.version }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Source Commit | \`${{ steps.clone.outputs.commit_short }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| SOURCE_DATE_EPOCH | \`${{ steps.epoch.outputs.epoch }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### PCR Values" >> $GITHUB_STEP_SUMMARY
          echo "| PCR | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-----|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| PCR0 | \`${{ steps.enclaver.outputs.pcr0 }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| PCR1 | \`${{ steps.enclaver.outputs.pcr1 }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| PCR2 | \`${{ steps.enclaver.outputs.pcr2 }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Release Image" >> $GITHUB_STEP_SUMMARY
          echo "| Type | Location |" >> $GITHUB_STEP_SUMMARY
          echo "|------|----------|" >> $GITHUB_STEP_SUMMARY
          echo "| Release Image | \`${{ steps.enclaver.outputs.release_image }}\` |" >> $GITHUB_STEP_SUMMARY
      
      # Callback to Nova Platform (optional - does not fail the build)
      - name: Callback to Nova Platform (Success)
        if: success() && github.event.inputs.app_id != '' && github.event.inputs.build_id != ''
        continue-on-error: true
        run: |
          echo "Sending success callback to Nova Platform..."
          curl -X POST "${{ secrets.NOVA_PLATFORM_API_URL }}/api/builds/callback" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${{ secrets.NOVA_PLATFORM_CALLBACK_API_KEY }}" \
            -d '{
              "app_id": ${{ github.event.inputs.app_id }},
              "build_id": ${{ github.event.inputs.build_id }},
              "status": "success",
              "image_uri": "${{ steps.enclaver.outputs.release_image }}",
              "image_digest": "${{ steps.enclaver.outputs.digest }}",
              "git_commit": "${{ steps.clone.outputs.commit_sha }}",
              "git_commit_short": "${{ steps.clone.outputs.commit_short }}",
              "pcr0": "${{ steps.enclaver.outputs.pcr0 }}",
              "pcr1": "${{ steps.enclaver.outputs.pcr1 }}",
              "pcr2": "${{ steps.enclaver.outputs.pcr2 }}",
              "github_run_id": "${{ github.run_id }}"
            }' || echo "Callback failed, but continuing..."
      
      - name: Callback to Nova Platform (Failure)
        if: failure() && github.event.inputs.app_id != '' && github.event.inputs.build_id != ''
        continue-on-error: true
        run: |
          echo "Sending failure callback to Nova Platform..."
          curl -X POST "${{ secrets.NOVA_PLATFORM_API_URL }}/api/builds/callback" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${{ secrets.NOVA_PLATFORM_CALLBACK_API_KEY }}" \
            -d '{
              "app_id": ${{ github.event.inputs.app_id }},
              "build_id": ${{ github.event.inputs.build_id }},
              "status": "failed",
              "error_message": "Build failed. See GitHub Actions run ${{ github.run_id }} for details.",
              "github_run_id": "${{ github.run_id }}"
            }' || echo "Callback failed, but continuing..."

